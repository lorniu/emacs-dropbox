;;; dropbox.el --- Dropbox Client -*- lexical-binding: t -*-

;; Copyright (C) 2022 lorniu <lorniu@gmail.com>

;; Author: lorniu <lorniu@gmail.com>
;; URL: https://github.com/lorniu/dropbox.el
;; Package-Requires: ((emacs "27.1") (pdd "0.2"))
;; Keywords: tools
;; SPDX-License-Identifier: MIT
;; Version: 2.0

;;; Commentary:

;; Dropbox client on Emacs.
;;
;; 1. Download `dropbox.el` and load it (with `load` or `require`)
;; 2. The first time, you should generate the config file with `M-x dropbox-gen-config`
;;    (You can reuse the one generated by `dropbox_uploader.sh`, compatible)
;; 3. Then use `dropbox-find` to search and pick file,
;;    Use `C-x C-f /db:` or `C-x C-f /db:/PATH-ON-DROPBOX` to open file
;;
;; Visit https://github.com/lorniu/dropbox.el for more informations
;;
;; https://www.dropbox.com/developers/documentation/http/documentation

;;; Code:

(require 'cl-lib)
(require 'json)
(require 'pdd)

(defgroup dropbox nil
  "Dropbox on Emacs."
  :prefix "dropbox-"
  :group 'applications)

(defcustom dropbox-debug nil
  "Toggle debug output."
  :type 'boolean)

(defcustom dropbox-config-file "~/.dropbox"
  "Use the config file generated by dropbox.shell."
  :type 'string)

(defcustom dropbox-http-backend pdd-backend
  "Http backend used. See `pdd-backend' for details."
  :type 'sexp)

(defconst dropbox-prefix "/db:")

(defvar dropbox--config nil)

(defvar dropbox--shared-storage (make-hash-table :test #'equal))

(defvar-local dropbox--files nil)

(defun dropbox-log (fmt-string &rest args)
  (when dropbox-debug
    (apply #'message (concat "\t[Dropbox] " fmt-string) args)))

(defun dropbox-normalize (path &optional force-prefix-p)
  (when path
    (when (string-match-p "/$" path)
      (setq path (substring path 0 -1)))
    (when (string-match-p (concat "^" dropbox-prefix) path)
      (setq path (substring path (length dropbox-prefix)))))
  (concat (if force-prefix-p dropbox-prefix) path))

(defun dropbox-file-p (filename)
  (string-prefix-p dropbox-prefix filename))


;;; API

(defun dropbox-request (url &rest args)
  (declare (indent 1))
  (pdd-then (unless (string-match-p "/oauth2" url) (dropbox-token))
    (lambda (token)
      (let ((pdd-headers (if token `((bear ,token))))
            (pdd-active-cacher nil)
            (pdd-shared-cache-storage dropbox--shared-storage)
            (pdd-backend dropbox-http-backend))
        (if-let* ((msg (plist-get args :progress)))
            (let* ((reporter (make-progress-reporter msg))
                   (pdd-peek (lambda (headers)
                               (let* ((total (string-to-number (alist-get 'content-length headers)))
                                      (percent (format "%.1f%%" (/ (* 100.0 (buffer-size)) total))))
                                 (progress-reporter-update reporter percent)))))
              (apply #'pdd url args))
          (apply #'pdd url args))))))

(defun dropbox--refresh-token (access-code app-key app-secret)
  (dropbox-request "https://api.dropbox.com/oauth2/token"
    :data `((grant_type . authorization_code)
            (code . ,access-code)
            (client_id . ,app-key)
            (client_secret . ,app-secret))
    :done (lambda (result)
            (alist-get 'refresh_token result))))

(defun dropbox--access-token (refresh-token app-key app-secret)
  (dropbox-request "https://api.dropbox.com/oauth2/token"
    :data `((grant_type . refresh_token)
            (refresh_token . ,refresh-token)
            (client_id . ,app-key)
            (client_secret . ,app-secret))
    :done (lambda (result)
            (cons (alist-get 'access_token result)
                  (time-add (current-time) (seconds-to-time (- (alist-get 'expires_in result) 120)))))))

(defun dropbox--get-current-account ()
  (dropbox-request "https://api.dropboxapi.com/2/users/get_current_account"
    :cache '(10000 account)
    :headers '(t json)
    :data "null"))

(defun dropbox--get-space-usage ()
  (dropbox-request "https://api.dropboxapi.com/2/users/get_space_usage"
    :cache '(60 space-usage)
    :headers '(t json)
    :data "null"))

(defun dropbox--list-folder (path)
  (dropbox-request "https://api.dropboxapi.com/2/files/list_folder"
    :cache '(3 list (data . path))
    :headers '(t json)
    :data `((path . ,(dropbox-normalize path))
            (recursive . :json-false)
            (include_media_info . :json-false)
            (include_deleted . :json-false)
            (include_has_explicit_shared_members . :json-false)
            (include_mounted_folders . t))
    :done (lambda (entries)
            (cl-coerce (alist-get 'entries entries) 'list))))

(defun dropbox--search (text &optional path)
  (dropbox-request "https://api.dropboxapi.com/2/files/search_v2"
    :cache '(10 search (data . query) (data . (options . path)))
    :headers '(t json)
    :data `((query . ,text)
            (options (file_status . active)
                     (filename_only . :json-false)
                     (max_results . 1000)
                     (path . ,(or (dropbox-normalize path) "")))
            (match_field_options (include_highlights . :json-false)))))

(defun dropbox--get-metadata (path &optional sync)
  (let ((pdd-sync sync)
        (path (dropbox-normalize path)))
    (if (string= path "")
        (pdd-then (dropbox-config)
          (lambda (_)
            '((name . "")
              (\.tag . "folder")
              (path_lower . "")
              (path_display . ""))))
      (dropbox-request "https://api.dropboxapi.com/2/files/get_metadata"
        :cache '(60 meta (data . path))
        :fail #'ignore ; ignore errors such as when check file exists
        :headers '(t json)
        :data `(("path" . ,path)
                ("include_media_info" . :json-false)
                ("include_deleted" . :json-false)
                ("include_has_explicit_shared_members" . :json-false))))))

(defun dropbox--create-folder (path)
  (dropbox-request "https://api.dropboxapi.com/2/files/create_folder_v2"
    :headers '(t json)
    :data `(("path" . ,(dropbox-normalize path))
            ("autorename" . :json-false))))

(defun dropbox--delete (file)
  (dropbox-request "https://api.dropboxapi.com/2/files/delete_v2"
    :headers '(t json)
    :data `(("path" . ,(dropbox-normalize file)))))

(defun dropbox--move (from to)
  (dropbox-request "https://api.dropboxapi.com/2/files/move_v2"
    :headers '(t json)
    :data `(("from_path" . ,(dropbox-normalize from))
            ("to_path" . ,(dropbox-normalize to)))))

(defun dropbox--copy (from to)
  (dropbox-request "https://api.dropboxapi.com/2/files/copy_v2"
    :headers '(t json)
    :data `(("from_path" . ,(dropbox-normalize from))
            ("to_path" . ,(dropbox-normalize to)))))

(defun dropbox--upload (from to &optional overwrite)
  (dropbox-request "https://content.dropboxapi.com/2/files/upload"
    :headers `(t ct-bin)
    :params `((arg . ,(encode-coding-string
                       (json-encode
                        `(("path" . ,(dropbox-normalize to))
                          ("mode" . ,(if overwrite "overwrite" "add"))
                          ("autorename" . t)
                          ("mute" . :json-false)
                          ("strict_conflict" . :json-false)))
                       'utf-8)))
    :data (with-temp-buffer
            (insert-file-contents-literally from)
            (set-buffer-multibyte nil)
            (buffer-string))))

(defun dropbox--download (path &optional zip?)
  (setq path (dropbox-normalize path)) ; application/octet-stream
  (when (and zip? (not (file-directory-p (dropbox-normalize path t))))
    (user-error "Download to .zip is used for dictionay"))
  (dropbox-request (concat "https://content.dropboxapi.com/2/files/download" (if zip? "_zip"))
    :params `((arg . ,(encode-coding-string (json-encode `(("path" . ,path))) 'utf-8)))
    :progress "Fetching"
    :done (lambda (r) (message "") r)))

;; (dropbox-token)
;; (dropbox--get-current-account)
;; (dropbox--get-space-usage)
;; (dropbox--list-folder "/vvv")
;; (dropbox--search "p")
;; (dropbox--get-metadata "/vvv")
;; (dropbox--get-metadata "/")
;; (dropbox--get-metadata "/vvv")
;; (dropbox--create-folder "/vvv/c2cc")
;; (dropbox--delete "/vvv/c2cc")
;; (dropbox--move "/vvv/bashrc.txt" "/vvv/bashrc-2.txt")
;; (dropbox--copy "/vvv/bashrc-2.txt" "/vvv/bashrc-4.txt")
;; (dropbox--upload "/home/vip/.bashrc" "/vvv/bashrc.txt")
;; (dropbox--download "/vvv/persons.json")
;; (dropbox--download "/vvv" nil)
;; (maphash (lambda (k v) (message "> %S" k)) dropbox-shared-storage)


;;; Authorization

;;;###autoload
(defun dropbox-gen-config ()
  "Generate the config file containing auth infomation."
  (interactive)
  (require 'widget)
  (if (file-exists-p dropbox-config-file)
      (user-error "Config file '%s' exists, delete it or give up" dropbox-config-file)
    (setq dropbox--config nil)
    (with-current-buffer (get-buffer-create "*Dropbox Config*")
      (let ((apps-url "https://www.dropbox.com/developers/apps")
            (auth-url "https://www.dropbox.com/oauth2/authorize?client_id=%s&token_access_type=offline&response_type=code")
            wkey wsec wcode)
        ;; init
        (kill-all-local-variables)
        (let ((inhibit-read-only t)) (erase-buffer))
        (remove-overlays)
        ;; widgets
        (widget-insert "Generate token for Dropbox (step by step)\n\n1. Click ")
        (widget-create 'link :value apps-url :notify (lambda (&rest _) (browse-url apps-url)))
        (widget-insert " to create/config a Dropbox App:

   - App type: 'Scoped access', Access: 'Full Dropbox'.
   - Permissions: Grant 'files.metadata.read/write', 'files.content.read/write'.
   - Settings: Note your 'App key' and 'App secret'.

2. Input 'App key' & 'App secret' that get from step 1\n\n")
        (setq wkey (widget-create 'editable-field :size 16 :format "   App key:    %v\n\n"))
        (setq wsec (widget-create 'editable-field :size 16 :format "   App secret: %v\n\n"))
        (widget-insert "3. Click ")
        (widget-create 'push-button
                       :notify (lambda (&rest _)
                                 (let ((app-key (string-trim (widget-value wkey)))
                                       (app-secret (string-trim (widget-value wsec))))
                                   (if (or (zerop (length app-key)) (zerop (length app-secret)))
                                       (message "Please input `app key' and `app secret' first")
                                     (browse-url (format auth-url app-key)))))
                       "Get Access Code")
        (widget-insert ", authorize in browser, and paste code here.\n\n")
        (setq wcode (widget-create 'editable-field :size 50 :format "   Access code: %v\n\n\n"))
        (widget-insert "If all ready, ")
        (widget-create 'push-button
                       :notify (lambda (&rest _)
                                 (let ((pdd-sync t)
                                       (app-key (string-trim (widget-value wkey)))
                                       (app-secret (string-trim (widget-value wsec)))
                                       (access-code (string-trim (widget-value wcode))))
                                   (if (cl-some (lambda (x) (zerop (length x))) (list app-key app-secret access-code))
                                       (message "Please make sure previous steps are ready")
                                     (pdd-then (dropbox--refresh-token access-code app-key app-secret)
                                       (lambda (refresh-token)
                                         (with-temp-file dropbox-config-file
                                           (insert (format "CONFIGFILE_VERSION=2.0\nOAUTH_APP_KEY=%s\nOAUTH_APP_SECRET=%s\nOAUTH_REFRESH_TOKEN=%s"
                                                           app-key app-secret refresh-token)))
                                         (kill-buffer-and-window)
                                         (message "File `%s` generated done!" dropbox-config-file))))))
                       "click here to Generate the config file")
        (widget-insert ", or kill this buffer to give up.\n")
        (set-buffer-modified-p nil)
        ;; apply
        (use-local-map widget-keymap)
        (widget-setup)
        ;; display
        (goto-char (point-min))
        (pop-to-buffer (current-buffer) '((display-buffer-at-bottom)))))))

(defun dropbox-config ()
  (if (file-exists-p dropbox-config-file)
      (or dropbox--config
          (with-temp-buffer
            (insert-file-contents dropbox-config-file)
            (cl-loop for line in (split-string (buffer-string) "\n")
                     if (string-match-p "=" line)
                     collect (let* ((linepair (split-string line "="))
                                    (key (intern (concat ":" (replace-regexp-in-string "oauth_" "" (downcase (car linepair))))))
                                    (value (cadr linepair)))
                               (cons key value ))
                     into fs finally return
                     (if (alist-get :refresh_token fs)
                         (setq dropbox--config fs)
                       (user-error "Load config file '%s' failed, please check and regenerate" dropbox-config-file))))
          (user-error "No '%s' found, please execute `M-x dropbox-gen-config' and follow the guide to generate one" dropbox-config-file))))

(defun dropbox-token ()
  (let ((config (dropbox-config)))
    (if-let* ((expired (alist-get :expired config))
              (token (alist-get :access_token config))
              (avail (and token expired (time-less-p (current-time) expired))))
        (if (eq pdd-sync t) token (pdd-resolve token))
      (message "[dropbox] Getting token...")
      (let* ((refresh-token (alist-get :refresh_token config))
             (token-and-etime (dropbox--access-token refresh-token (alist-get :app_key config) (alist-get :app_secret config)))
             (save (lambda (lst)
                     (setf (alist-get :expired dropbox--config) (cdr lst))
                     (setf (alist-get :access_token dropbox--config) (car lst)))))
        (if (eq pdd-sync t)
            (funcall save token-and-etime)
          (pdd-then token-and-etime save))))))


;;; Handler

;;;###autoload
(defun dropbox-handler (operation &rest args)
  (let ((handler (intern (format "dropbox-handle:%s" operation))))
    (if (fboundp handler)
        (apply handler args)
      (dropbox-run-real-handler operation args))))

(defun dropbox-run-real-handler (operation args)
  (let* ((inhibit-file-name-handlers `(dropbox-handler
                                       tramp-file-name-handler
                                       tramp-vc-file-name-handler
                                       tramp-completion-file-name-handler
                                       . ,inhibit-file-name-handlers))
         (inhibit-file-name-operation operation))
    (apply operation args)))

(defun dropbox-handle:file-exists-p (filename)
  (dropbox-log "[handler] file-exists-p: %s" filename)
  (setq filename (dropbox-normalize filename))
  ;; patch for some special cases, for performance
  (cond ((string-match-p "^/?$" filename) t)
        ((string-match-p "~/" filename) nil)
        ((string-match-p "[/.]tags$" filename) nil) ; citre
        (t (ignore-errors (dropbox--get-metadata filename t)))))

(defun dropbox-handle:file-readable-p (filename)
  (cond ((string-match-p "\\.editorconfig" filename) nil) ; boring editorconfig! disable hardcode
        (t t)))

(defun dropbox-handle:file-directory-p (filename)
  (dropbox-log "[handler] file-directory-p: %s" filename)
  (let* ((filename (dropbox-normalize filename))
         (metadata (ignore-errors (dropbox--get-metadata filename t))))
    (and metadata (string= (alist-get '\.tag metadata) "folder"))))

(defun dropbox-handle:file-executable-p (filename)
  (dropbox-handle:file-directory-p filename))

(defun dropbox-handle:file-regular-p (file)
  (not (file-directory-p file)))

(defun dropbox-handle:file-remote-p (file &optional identification _connected)
  (cl-case identification
    ((method) dropbox-prefix)
    ((user) "")
    ((host) "")
    ((localname) (dropbox-normalize file))
    (t (concat dropbox-prefix "/"))))

(defun dropbox-handle:expand-file-name (name &optional dir)
  (if (string-prefix-p dropbox-prefix name) name
    (dropbox-run-real-handler #'expand-file-name (list name dir))))

(defun dropbox-handle:file-name-directory (filename)
  (if (string-match (concat "^\\(" dropbox-prefix ".*/\\).*$") filename)
      (match-string 1 filename)
    dropbox-prefix))

(defun dropbox-handle:file-name-nondirectory (filename)
  (if (string-match (concat "^" dropbox-prefix ".*/\\(.*\\)$") filename)
      (match-string 1 filename)
    (substring filename 4)))

;; CRUD

(defun dropbox-handle:make-directory (dir &optional _parents)
  (setq dir (dropbox-normalize dir))
  (pdd-then (dropbox--create-folder dir)
    (lambda (_) (message "Folder %s created!" dir))))

(defun dropbox-handle:delete-file (filename &optional _trash)
  (setq filename (dropbox-normalize filename))
  (pdd-then (dropbox--delete filename)
    (lambda (_) (message "Delete %s done!" filename))))

(defun dropbox-handle:delete-directory (directory &optional _recursive _trash)
  (setq directory (dropbox-normalize directory))
  (dropbox-handle:delete-file directory))

(defun dropbox-handle:copy-file (file newname &optional _ok-if-already-exists _keep-time _preserve-uid-gid _preserve-selinux-context)
  (cond ((and (dropbox-file-p file) (dropbox-file-p newname))
         (pdd-then (dropbox--copy (dropbox-normalize file) (dropbox-normalize newname))
           (lambda (_) (message "Copy done."))))
        ((and (dropbox-file-p file) (not (dropbox-file-p newname)))
         (rename-file (file-local-copy file) newname))
        ((and (not (dropbox-file-p file)) (dropbox-file-p newname))
         (pdd-then (dropbox--upload file newname)
           (lambda (_) (message "Upload done."))))))

(defun dropbox-handle:copy-directory (directory newname &optional keep-time parents copy-contents)
  (cond ((and (dropbox-file-p directory) (dropbox-file-p newname))
         (if parents (make-directory
                      (file-name-directory (directory-file-name newname))
                      parents))
         (copy-file directory newname nil keep-time parents copy-contents))
        ((and (dropbox-file-p directory) (string-match-p "\\.zip$" newname))
         (pdd-then (dropbox--download directory t)
           (lambda (content)
             (with-temp-file newname (insert content)))))
        (t (error "Copying directory from local to remote is not supported"))))

(defun dropbox-handle:rename-file (file newname &optional ok-if-already-exists)
  (cond ((and (dropbox-file-p file) (dropbox-file-p newname))
         (pdd-then (dropbox--move (dropbox-normalize file) (dropbox-normalize newname))
           (lambda (_) (message "Done."))))
        ((and (dropbox-file-p file) (not (dropbox-file-p newname)))
         (copy-file file newname ok-if-already-exists)
         (delete-file file t))
        ((and (not (dropbox-file-p file)) (dropbox-file-p newname))
         (copy-file file newname ok-if-already-exists)
         (delete-file file t))))

;; Contents

(defun dropbox--set-progress (&optional index)
  (let* ((index (or index 0))
         (finished (or (null dropbox--files) (= (length dropbox--files) index))))
    (save-excursion
      (goto-char (point-min))
      (re-search-forward "), " nil t)
      (with-silent-modifications
        (delete-region (point) (line-end-position))
        (insert (if finished
                    (propertize (format "%s items" index)
                                'pointer 'arrow
                                'help-echo (format "%d" (length dropbox--files)))
                  (format "loading %s/%s" index (length dropbox--files))))
        (cond ((null dropbox--files)
               (message "Loading...done with nothing found."))
              (finished
               (message "Loading...done")))))))

(defun dropbox-handle:file-modes (&rest _) 492)

(defun dropbox-handle:file-attributes (filename &optional _ ometadata)
  (let* ((file (dropbox-normalize filename))
         (meta (or ometadata (dropbox--get-metadata file t)))
         (date (date-to-time (or (alist-get 'client_modified meta) "0000-01-01T00:00:00Z")))
         (folder (if meta (string= "folder" (alist-get '.tag meta)) (file-directory-p file)))
         (size (if meta (alist-get 'size meta)))
         (perm (concat (if folder "d" "-") "rwxr-xr--")))
    ;; folder? / links / UID / GID / atime / mtime / ctime / size / perm
    (list folder 1 0 0 date date date (or size 0) perm t nil nil)))

(defun dropbox-handle:insert-directory (filename _switches &optional _wildcard full-directory-p)
  (dropbox-log "[handler] insert-directory: %s" filename)
  (let* ((filename (expand-file-name filename))
         (buffer (current-buffer))
         (create-row (lambda (entry)
                       (let* ((name (alist-get 'name entry))
                              (attrs (dropbox-handle:file-attributes name nil entry))
                              (prefix (format "  %s %2d %2s %2s %8s %s "
                                              (elt attrs 8) (elt attrs 1) (elt attrs 2) (elt attrs 3)
                                              (file-size-human-readable (elt attrs 7))
                                              (format-time-string "%Y-%m-%d %H:%M" (elt attrs 4))))
                              (suffix (with-temp-buffer
                                        (insert name "\n")
                                        (put-text-property (point-min) (- (point-max) 1) 'dired-filename t)
                                        (buffer-string))))
                         (with-current-buffer buffer
                           (goto-char (point-max))
                           (with-silent-modifications
                             (insert prefix)
                             (save-excursion (insert suffix))))))))
    (if (not full-directory-p)
        (pdd-then (dropbox--get-metadata filename) create-row)
      (pdd-async
        (let* ((reporter (make-progress-reporter "Loading"))
               (usage (await (dropbox--get-space-usage)))
               (used (alist-get 'used usage))
               (allocated (alist-get 'allocated (alist-get 'allocation usage))))
          (with-current-buffer buffer
            (with-silent-modifications
              (goto-char (point-max))
              (insert (format "  dropbox: %s (total %s, used %.0f%%), loading...\n"
                              (file-size-human-readable used)
                              (file-size-human-readable allocated)
                              (/ (* used 100.0) allocated))))))
        (if (setq dropbox--files (await (dropbox--list-folder filename)))
            (cl-loop for entry in dropbox--files
                     for index from 1
                     do (save-excursion
                          (funcall create-row entry)
                          (progress-reporter-update reporter (alist-get 'name entry))
                          (dropbox--set-progress index)))
          (dropbox--set-progress))))))

(defun dropbox-handle:insert-file-contents (filename &optional visit beg end replace)
  (dropbox-log "[handler] insert-file-contents: %s" filename)
  (let ((tmpfile (make-temp-file (file-name-nondirectory filename))))
    (condition-case err
        (let ((pdd-sync t) count)
          (when (file-exists-p filename)
            (with-temp-file tmpfile
              (set-buffer-multibyte nil)
              (insert (dropbox--download filename)))
            (if replace (erase-buffer))
            (insert-file-contents tmpfile visit beg end)
            (setq count (buffer-size)))
          (when visit
            (setf buffer-file-name filename)
            (setf buffer-read-only (not (file-writable-p filename)))
            (set-visited-file-modtime (current-time))) ; assume that no concurrent edit
          (cons filename count))
      (error (ignore-errors (delete-file tmpfile))
             (signal 'user-error (cdr err))))))

(defun dropbox-handle:write-region (beg end filename &optional append visit _lockname _mustbenew)
  (dropbox-log "[handler] write-region: %s, %s, %s" filename beg end)
  (cl-assert (not append))
  (let ((pdd-sync nil)
        (buffer (current-buffer))
        (tmpfile (make-temp-file (file-name-nondirectory filename)))
        (coding-system-for-write buffer-file-coding-system))
    (condition-case err
        (let ((inhibit-modification-hooks t))
          (write-region beg end tmpfile nil 'no-message))
      (error (ignore-errors (delete-file tmpfile))
             (user-error "Write error: %s" err)))
    (pdd-then (dropbox--upload tmpfile filename t)
      (lambda (_)
        (ignore-errors (delete-file tmpfile))
        (with-current-buffer buffer
          (setq-local create-lockfiles nil)
          (when (stringp visit)
            (set-visited-file-name visit))
          (when (or (eq t visit) (stringp visit))
            (set-buffer-modified-p nil))
          (when (or (eq t visit) (eq nil visit) (stringp visit))
            (message "Wrote %s" filename))
          (setq save-buffer-coding-system coding-system-for-write)))
      (lambda (r)
        (ignore-errors (delete-file tmpfile))
        (message "Write failed: %s" r)))))

(defun dropbox-handle:file-local-copy (filename)
  (dropbox-log "[handler] file-local-copy: %s" filename)
  (if (not (file-exists-p filename))
      (error "File to copy doesn't exist")
    (save-excursion
      (let* ((newname (make-temp-file (file-name-nondirectory filename) nil
                                      (concat "." (file-name-extension filename)))))
        (with-temp-file newname
          (set-buffer-file-coding-system 'raw-text)
          (insert-file-contents-literally filename))
        newname))))

(defun dropbox-handle:dired-insert-directory (dir switches &optional file-list wildcard _hdr)
  (dropbox-log "[handler] dired-insert-directory: %s" dir)
  (if file-list
      (cl-loop for file in file-list
               do (insert-directory (concat dir file) switches))
    (insert-directory dir switches wildcard t)))

(defun dropbox-handle:load (file &optional noerror nomessage nosuffix must-suffix)
  (let (localfile)
    (condition-case nil
        (setq localfile (file-local-copy file))
      (error (user-error "File %s not found" file)))
    (when (and localfile (file-exists-p localfile))
      (let ((signal-hook-function (unless noerror signal-hook-function))
	        (inhibit-message (or inhibit-message nomessage)))
        (unwind-protect
            (load localfile noerror t nosuffix must-suffix)
          (delete-file localfile))))))

;; Rude handling

(defun dropbox-handle:file-writable-p (_) t)
(defun dropbox-handle:file-owner-preserved-p (_) t)
(defun dropbox-handle:directory-files (&rest _) nil)
(defun dropbox-handle:make-symbolic-link (&rest _) nil)
(defun dropbox-handle:add-name-to-file (&rest _) nil)
(defun dropbox-handle:dired-compress-file (&rest _) nil)
(defun dropbox-handle:find-backup-file-name (&rest _) nil)
(defun dropbox-handle:unhandled-file-name-directory (&rest _) nil)
(defun dropbox-handle:start-file-process (&rest _) nil)
(defun dropbox-handle:process-file (&rest _) nil)
(defun dropbox-handle:shell-command (&rest _) nil)
(defun dropbox-handle:executable-find (_) nil)
(defun dropbox-handle:vc-registered (&rest _) nil)
(defun dropbox-handle:set-file-modes (&rest _) nil)
(defun dropbox-handle:set-file-times (&rest _) nil)
(defun dropbox-handle:set-visited-file-modtime (&rest _) nil)
(defun dropbox-handle:verify-visited-file-modtime (&optional _buf) t)
(defun dropbox-handle:file-selinux-context (&rest _) nil)


;;; Patches

(declare-function project--find-in-directory "ext:project.el" t t)

(defun dropbox-project--find-in-directory-advice (fn dir)
  "Tell directly which DIR is the project root. FN is the origin function."
  (if (dropbox-file-p dir)
      (cons 'transient dropbox-prefix)
    (funcall fn dir)))

(advice-add #'project--find-in-directory :around #'dropbox-project--find-in-directory-advice)



;;;###autoload
(defun dropbox-find (&optional choose-dir)
  "Search files from Dropbox and open it.
It will search all files, with a prefix CHOOSE-DIR
will allow you specify a dir to search."
  (interactive "P")
  (let ((input (read-string "Search Dropbox with: ")))
    (when (< (length (replace-regexp-in-string " " "" input)) 1)
      (user-error "Maybe input is too short"))
    (let* ((dir (when choose-dir
                  (let* ((def (if (dropbox-file-p default-directory) (dropbox-normalize default-directory)))
                         (sel (read-string "Searching in directory: " def)))
                    (cond ((or (null sel) (string= sel "/") (string= sel "")) nil)
                          (t (if (string-prefix-p "/" sel) sel (concat "/" sel)))))))
           (desc (if dir (concat " in '" dir "'") ""))
           (prompt (format "Dropbox files%s (matching %s): " desc input)))
      (message "Searching%s..." desc)
      (pdd-let*
          ((files (await (dropbox--search input dir)))
           (candicates (cl-loop for file across (alist-get 'matches files)
                                for metadata = (alist-get 'metadata (alist-get 'metadata file))
                                when (string= (alist-get '\.tag metadata) "file")
                                collect (dropbox-normalize (alist-get 'path_display metadata) t))))
        (when (< (length candicates) 1)
          (user-error "Nothing found on Dropbox%s with '%s'" desc input))
        (let ((f (completing-read prompt candicates)))
          (if (dropbox-file-p f)
              (find-file f)
            (user-error "Are you taking an odd file '%s' as a dropbox file?" f)))))))

;;;###autoload
(defun dropbox-browser (&optional dir)
  "Open current directory or DIR in your browser."
  (interactive)
  (let* ((home "https://www.dropbox.com/home")
         (dir (or dir (if (dropbox-file-p default-directory) (dropbox-normalize default-directory))))
         (path (read-string "Directory open in browser: " dir)))
    (unless (string-prefix-p "/" path)
      (user-error "Maybe you input a invalid path"))
    (browse-url (concat home path))))

;;;###autoload
(add-to-list 'file-name-handler-alist
             `(,(concat "\\`" dropbox-prefix) . dropbox-handler))

(provide 'dropbox)

;;; dropbox.el ends here
